// Generated by CoffeeScript 1.8.0
(function() {
  var abort, config, configText, finish, fs, http, newStatus, updateStatus, urlList;

  fs = require('fs');

  http = require('http');

  urlList = 'http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest';

  newStatus = function(str) {
    return process.stdout.write("* " + str + "\n");
  };

  updateStatus = function(str) {
    return process.stdout.write("\r* " + str);
  };

  abort = function(reason) {
    newStatus(reason);
    newStatus('Task aborted');
    return process.exit();
  };

  finish = function() {
    newStatus('Task finished');
    return process.exit();
  };

  newStatus('Task started');

  try {
    configText = fs.readFileSync('config.json', 'utf-8');
  } catch (_error) {
    abort('Error while reading config from config.json');
  }

  try {
    config = JSON.parse(configText);
  } catch (_error) {
    abort('Config is not valid JSON');
  }

  if (config.route["default"] == null) {
    abort('Default route not specified');
  }

  newStatus('Downloading');

  http.get(urlList, function(res) {
    var responseText, sizeDownloaded, sizeTotal;
    newStatus("HTTP response status code: " + res.statusCode);
    sizeTotal = parseInt(res.headers['content-length']);
    sizeDownloaded = 0;
    responseText = '';
    return res.on('data', function(chunk) {
      responseText += chunk;
      sizeDownloaded += chunk.length;
      return updateStatus("Receiving " + (parseInt(sizeDownloaded / sizeTotal * 100)) + "% (" + sizeDownloaded + " / " + sizeTotal + ")");
    }).on('end', function() {
      var bsearchCode, code, ipList, listCode, mainCode, maskList, name, nonDefault, patten, proxy, proxyList, proxyNum, region, regionCode, result, route, routeList, theDefault, theProxy, theRegion, _i, _len, _ref, _ref1;
      updateStatus('\n');
      newStatus('Arranging data');
      routeList = [];
      theRegion = void 0;
      _ref = config.route;
      for (region in _ref) {
        proxy = _ref[region];
        if (!(region !== 'default')) {
          continue;
        }
        theRegion = region;
        if (region === 'special') {
          routeList.push.apply(routeList, [
            {
              ip: 0x00000000,
              mask: 24,
              proxy: proxy
            }, {
              ip: 0x0A000000,
              mask: 24,
              proxy: proxy
            }, {
              ip: 0x7f000000,
              mask: 24,
              proxy: proxy
            }, {
              ip: 0xA9FE0000,
              mask: 16,
              proxy: proxy
            }, {
              ip: 0xAC100000,
              mask: 20,
              proxy: proxy
            }, {
              ip: 0xC0000000,
              mask: 8,
              proxy: proxy
            }, {
              ip: 0xC0000200,
              mask: 8,
              proxy: proxy
            }, {
              ip: 0xC0586300,
              mask: 8,
              proxy: proxy
            }, {
              ip: 0xC0A80000,
              mask: 16,
              proxy: proxy
            }, {
              ip: 0xC6120000,
              mask: 17,
              proxy: proxy
            }
          ]);
        } else {
          patten = new RegExp("^apnic\\|" + region + "\\|ipv4\\|(\\d*)\\.(\\d*)\\.(\\d*)\\.(\\d*)\\|(\\d*)\\|\\d*\\|.*?$", 'img');
          while (result = patten.exec(responseText)) {
            routeList.push({
              ip: ((result[1] << 24) | (result[2] << 16) | (result[3] << 8) | result[4]) >>> 0,
              mask: Math.log(result[5]) / Math.LN2,
              proxy: proxy
            });
          }
        }
      }
      routeList.sort(function(a, b) {
        return a.ip - b.ip;
      });
      ipList = [];
      maskList = [];
      proxyList = [];
      theProxy = void 0;
      nonDefault = void 0;
      theDefault = void 0;
      proxyNum = 0;
      _ref1 = config.proxy;
      for (name in _ref1) {
        proxy = _ref1[name];
        ++proxyNum;
        theProxy = proxy;
        if (name === config.route["default"]) {
          theDefault = proxy;
        } else {
          nonDefault = proxy;
        }
      }
      for (_i = 0, _len = routeList.length; _i < _len; _i++) {
        route = routeList[_i];
        if (config.proxy[route.proxy] !== theDefault) {
          ipList.push(route.ip);
          maskList.push(route.mask);
          proxyList.push(route.proxy);
        }
      }
      if (proxyNum === 1) {
        code = "function FindProxyForURL(){return \"" + theProxy + "\"}";
      } else {
        listCode = "var i=" + (JSON.stringify(ipList)) + ",m=" + (JSON.stringify(maskList));
        if (proxyNum === 2) {
          listCode += ';';
          regionCode = "function g(){return \"" + nonDefault + "\"}";
        } else {
          listCode += ",r=" + (JSON.stringify(proxyList)) + ",c=" + (JSON.stringify(config.proxy)) + ";";
          regionCode = 'function g(n){return c[r[n]]}';
        }
        bsearchCode = 'function b(t){var l=0,r=i.length,m;while(l+1<r){m=parseInt((l+r)/2);if(t>i[m])l=m;else r=m}return l}';
        mainCode = "function FindProxyForURL(url,host){var p=dnsResolve(host).match(/(\\d*)\\.(\\d*)\\.(\\d*)\\.(\\d*)/),q=(p[1]<<24|p[2]<<16|p[3]<<8|p[4])>>>0;if((n=b(q))&&i[n]>>>m[n]==q>>>m[n])return g(n);else return \"" + theDefault + "\"}";
        code = listCode + regionCode + bsearchCode + mainCode;
      }
      fs.writeFileSync('proxy.pac', code);
      return finish();
    });
  }).on('error', function(err) {
    return abort(err.message);
  });

}).call(this);
